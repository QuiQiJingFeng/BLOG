---
layout: post
title:  "相等性比较"
image: ''
date:   2021-05-27 19:19:34
tags:
- C#
description: ''
categories: 
- C#
---
#### 有时需要比较两个值是否相等。 在某些情况下，测试的是“值相等性”，也称为“等效性”，这意味着两个变量包含的值相等。 在其他情况下，必须确定两个变量是否引用内存中的同一基础对象

#### 引用相等性
```c#
using System;
class Test
{
    public int Num { get; set; }
    public string Str { get; set; }

    static void Main()
    {
        Test a = new Test() { Num = 1, Str = "Hi" };
        Test b = new Test() { Num = 1, Str = "Hi" };

        bool areEqual = System.Object.ReferenceEquals(a, b);
        // False:
        System.Console.WriteLine("ReferenceEquals(a, b) = {0}", areEqual);

        // Assign b to a.
        b = a;

        // Repeat calls with different results.
        areEqual = System.Object.ReferenceEquals(a, b);
        // True:
        System.Console.WriteLine("ReferenceEquals(a, b) = {0}", areEqual);

        // Keep the console open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
}
```
#### 值相等性
```c#
int a = GetOriginalValue();  
int b = GetCurrentValue();  
  
// Test for value equality.
if (b == a)
{  
    // The two integers are equal.  
} 
```

#### 浮点值的值相等性
由于值之间的精度差别，或由于一个或两个值的精度损失，应相同的浮点值经常会出现不相等，因为其最小有效位之间存在差异.  
因此，调用 Equals 方法来确定两个值是否相等，或调用 CompareTo 方法来确定两个值之间的关系 Double ，通常会产生意外结果。 在下面的示例中，这很明显，其中两个明显相等 Double 的值是不相等的，因为第一个值的精度为15位，而第二个值为17。
```c#
using System;

public class Example
{
   public static void Main()
   {
      double value1 = .333333333333333;
      double value2 = 1.0/3;
      Console.WriteLine("{0:R} = {1:R}: {2}", value1, value2, value1.Equals(value2));
   }
}
// The example displays the following output:
//        0.333333333333333 = 0.33333333333333331: False
```
采用不同的代码路径并以不同的方式操作的计算值通常证明不相等。 在下面的示例中，一个 Double 值为平方，然后计算平方根以还原原始值。 第二个 Double 比3.51 和 squared 相乘，然后将结果的平方根除以3.51 来还原原始值。 尽管两个值看起来相同，但对方法的调用 Equals(Double) 指示它们不相等。 使用 "R" 标准格式字符串返回显示每个 Double 值的所有有效位的结果字符串，显示第二个值小于第一个值 .0000000000001
```c#
using System;

public class Example
{
   public static void Main()
   {
      double value1 = 100.10142;
      value1 = Math.Sqrt(Math.Pow(value1, 2));
      double value2 = Math.Pow(value1 * 3.51, 2);
      value2 = Math.Sqrt(value2) / 3.51;
      Console.WriteLine("{0} = {1}: {2}\n",
                        value1, value2, value1.Equals(value2));
      Console.WriteLine("{0:R} = {1:R}", value1, value2);
   }
}
// The example displays the following output:
//    100.10142 = 100.10142: False
//
//    100.10142 = 100.10141999999999
```
如果精度损失可能会影响比较结果，则可以采用以下任意一种方法调用 Equals 或 CompareTo 方法：  
* 调用 Math.Round 方法以确保这两个值具有相同的精度。 下面的示例修改了上一个示例，以使用此方法，以使两个小数值相等。
```c#
using System;

public class Example
{
   public static void Main()
   {
      double value1 = .333333333333333;
      double value2 = 1.0/3;
      int precision = 7;
      value1 = Math.Round(value1, precision);
      value2 = Math.Round(value2, precision);
      Console.WriteLine("{0:R} = {1:R}: {2}", value1, value2, value1.Equals(value2));
   }
}
// The example displays the following output:
//        0.3333333 = 0.3333333: True
```
