---
layout: post
title:  "绘制线条问题"
image: ''
date:   2024-09-13 19:11:43
tags:
- Cocos
description: ''
categories: 
- Cocos
---
# 1. 膨胀效应
在曲线拐角处（特别是夹角小于90度的情况），随着线段宽度的增加，拐角部分的宽度会显著扩大。  
这种现象在计算机图形学中被称为膨胀效应（Miter Effect）。  
膨胀效应是因为当两个线段相交时，如果角度很小，线段的厚度会沿着拐角的两侧进行扩展，从而导致拐角部分变得过宽。  
![图片](..\assets\img\shader\line1.png)  
可以看到斜着的绿色的线条长度要比竖着的更长。

在现实世界中，当一条粗的绳子弯曲成90度时，拐角会在物理作用下形成一个平滑的圆弧。  
或者绳子过于粗的情况下甚至无法弯曲成90度,因为挤压

![图片](..\assets\img\shader\line2.png)  
圆角（Round Join）是处理线段拐角的经典方法之一。它通过在两条相交的线段之间插入一段圆弧来平滑过渡，避免出现尖角。  

实现步骤：
1. 确定交点：假设有两条线段，它们的交点是拐角的顶点。我们需要确定这个交点的坐标。
2. 计算角度：计算两条线段之间的夹角（通常用余弦定理或向量点积计算）。
3. 生成圆弧：以交点为圆心，插入一段圆弧，这段圆弧的半径(大于等于)线段的半宽度。圆弧的长度和曲率可以根据线段宽度和夹角来调整。
4. 连接线段：将生成的圆弧与两侧的线段平滑连接。  
圆弧生成公式：  

* 假设两条线段的交点为 P，线段的宽度为𝑤，圆弧的半径为𝑟。 
* 圆弧可以通过几何方式生成，参数化方程如下：
x(t)=Px + r⋅cos(t)
𝑦(𝑡)=P𝑦 + 𝑟⋅sin(𝑡)
其中，t 是从𝜃1到θ2的弧度范围，对应两条线段的方向。

优点：
* 视觉平滑：圆弧拐角看起来非常自然，符合人类视觉对柔性物体的认知。
* 控制简便：通过简单调整圆弧的半径，可以控制拐角的圆滑程度。 

PS:注意如果圆弧半径等于线段的半宽度,可以看到内侧夹角就会出现90度垂直的情况。  
正常应该是黑色虚线这样的带内弯曲线会更好看一点。 

方法2：平滑插值（Smooth Interpolation）  
另一种平滑拐角的方法是通过平滑插值（例如Bézier曲线）来代替简单的线段连接。
步骤：
1. Bézier曲线：在拐角处使用二次或三次 Bézier 曲线，创建平滑过渡。这是一种在计算机图形学中广泛使用的方式，可以生成极为光滑的曲线。
2. 控制点：选择交点附近的控制点，生成平滑的过渡曲线。
动态调整：随着两条线段的角度变化，Bézier曲线的控制点可以动态调整，保证平滑的效果。  
优点：
* 非常光滑：可以实现极为平滑的曲线过渡，适合高质量渲染。
* 灵活：适用于任意角度的线段连接。  
缺点：
* 计算复杂性高：相对于简单的圆角和斜角化，Bézier曲线的实现和计算较为复杂。




# 2. 平滑曲线梯度距离估算  
通过使用函数的梯度信息，可以更准确地估计像素与曲线之间的距离，从而保持曲线的恒定厚度。这种方法称为“基于梯度的距离估计”。  
```c
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // coordinates
    float w = 1.0/iResolution.y; // size of a pixel
    float x = fragCoord.x * w;
    float y = fragCoord.y * w;
    
    // function f(x) and naive distance
    float f = 0.5 + 0.005/x + 0.01*x/(x-1.0) + 0.1*sin(x*20.0);
    float d = abs(f-y);
    
    // 启用或禁用梯度修正
    if( mod(iTime,2.0)>1.0 )
    {
        //使用梯度修正距离估计
        float fy = -0.005/(x*x) - 0.01/((x-1.0)*(x-1.0)) + 0.1*20.0*cos(20.0*x);
        fy = min( abs(fy), 40.0 );
        // 梯度修正公式
        d /= sqrt( 1.0 + fy*fy );
    }
    else
    {
        // 不使用梯度修正，使用一个常量修正
        d *= 0.707107;
    }
    
    // background
    vec3 col = vec3(0.15);

    // graph
    float thickness = iResolution.y/135.0;
    // graph thickness is 8 pixels at 1080p
    // cubic filtering is 2 pixels wide
    col = mix( col, vec3(0.0,0.7,1.0), smoothstep((0.5*thickness+2.0)*w,
                                                  (0.5*thickness+0.0)*w,
                                                   d) );
    fragColor = vec4(col,1.0);
}
```
1. 像素坐标计算  
首先，代码计算了当前像素的坐标，标准化为图像的高度：
```c
float w = 1.0/iResolution.y; // 一个像素的大小
float x = fragCoord.x * w;
float y = fragCoord.y * w;
```
* x 和 y 是当前像素的归一化坐标，用来评估曲线函数和距离。  
2. 曲线函数 f(x) 及其距离估计  
f(x) 是曲线的定义函数，它根据 x 生成对应的 y 值：
```c
float f = 0.5 + 0.005/x + 0.01*x/(x-1.0) + 0.1*sin(x*20.0);
float d = abs(f - y);
```
* f(x) 是基于一些函数组合（如分数、正弦函数等）的复杂函数，生成一条曲线。
* d = abs(f - y) 是简单的“函数与像素”距离估计：当前像素的 y 坐标和曲线 f(x) 的差值。  
3. 基于梯度的改进距离估计  
为了更准确地估计距离，代码使用了曲线函数的梯度信息来调整距离估计。梯度（即函数的导数）表示曲线的变化率。如果曲线的变化率很大（曲线陡峭），简单的垂直距离估计将不准确，因此通过梯度来修正距离。  
计算导数（梯度）：  
```c
float fy = -0.005/(x*x) - 0.01/((x-1.0)*(x-1.0)) + 0.1*20.0*cos(20.0*x);
fy = min(abs(fy), 40.0);
```
* fy 是 f(x) 的一阶导数，表示 f(x) 在 x 处的变化率。
* min(abs(fy), 40.0) 用于限制导数的值，防止导数过大影响距离估计。  
修正距离估计：  
```c
d /= sqrt(1.0 + fy * fy);
```
* 使用了一个经典的梯度修正公式 d / sqrt(1 + fy^2)。这个公式将梯度的影响考虑进去，通过减少 d 来避免在曲线陡峭的地方出现不准确的距离估计。
* 当梯度较大时，sqrt(1 + fy * fy) 会增加，从而减少 d，表示在曲线陡峭的区域，距离的修正更为明显
4. 启用或禁用梯度修正  
```c
if (mod(iTime, 2.0) > 1.0) {
    // 使用梯度修正距离估计
} else {
    // 不使用梯度修正，使用一个常量修正
    d *= 0.707107;
}
```
* 当 iTime 的余数大于 1 时，启用梯度修正；否则使用常量 0.707107 来修正距离。
5. 绘制曲线  
```c
float thickness = iResolution.y / 135.0;  // 曲线的厚度
col = mix(col, vec3(0.0, 0.7, 1.0), smoothstep((0.5 * thickness + 2.0) * w, (0.5 * thickness + 0.0) * w, d));
```  
* smoothstep 函数使得曲线边缘平滑过渡，基于修正后的距离 d 来确定曲线的颜色。  

6. 梯度修正公式的适用性    
梯度修正公式 d / sqrt(1 + fy^2) 是在图形学和距离场（Distance Fields）中常用的简单方法，用于处理曲线附近的距离估计。它的基础思想是，当曲线斜率较大时，简单的垂直距离 d = abs(f - y) 并不能准确反映像素到曲线的距离，因此需要用梯度（导数）来修正。  
这个公式适用于以下情况：
1. 曲线变化平缓：曲线没有急剧的变化（即导数不会剧烈波动）。
2. 局部估计：公式假设在某个小区域内，曲线的梯度是平滑的，不存在剧烈的转折。
3. 固定曲线形态：曲线 f(x) 的形式是确定的，公式中的梯度是从当前函数导数直接计算得出的。  
__对于曲线变化较大、形态复杂的情况，这种方法会有一些局限性，因为它只使用了单个点的局部梯度信息。它并不会全局搜索或通过优化来调整估计值,梯度修正公式 d / sqrt(1 + fy^2) 是一种几何上的修正方式，而不是优化过程。它的目的是调整简单的垂直距离估计，使得距离更准确__  
