---
layout: post
title:  "Unity性能优化"
image: ''
date:   2022-08-16 14:04:58
tags:
- Unity
description: ''
categories: 
- Unity
---
[参考文档](http://robotinvader.com/blog/?p=438)
人们对 Android 尤其谨慎，Android 设备种类繁多，给定设备的性能特征并不总是很明显。然而，我们发现，尽管各种移动 GPU 的哲学设计存在很大差异，但我们可以遵循一些简单的规则，让我们在几乎所有东西上都能正常运行。以下是我们在设计性能场景时遵循的清单：  

1. Fill(填充)是你的敌人。每次写入像素都会产生成本。在几乎所有可用的移动芯片组上，填充屏幕像素，即使只是纯色，也是一项昂贵的操作。即使移动 GPU 在这方面做得更好，屏幕分辨率似乎也以完全相同的速度增加。```性能下降的第一大原因是像素过度绘制——在帧中多次写入太多像素。```
2. 绘制调用很昂贵。每次你告诉 OpenGL ES 绘制一个顶点缓冲区时，调用本身都是有代价的。实际上，在大多数设备上，我认为在选择要绘制的顶点时涉及的状态开关会产生实际成本。如果您要多次绘制同一个缓冲区，则第一次绘制调用将比后续调用更昂贵。```但一般来说，我们会尽量减少draw call的数量。```在 发条骑士 2 中，我们每帧大约有 100 – 120 个。  Dungeon Slots每帧少于 40 个。
3. 灯很贵。 根据您实现照明的方式，```实时灯光可能会破坏您在移动设备上的表现```。灯光通常需要将多组几何体提交给 GPU，或者多次通过被照亮的像素，或者在着色器中使用比 GPU 可用的更多的高精度寄存器。实际成本归结为单个实施，但灯光可以通过多种方式影响您的性能。
4. 注意顶点蠕变。许多移动设备实际上非常擅长处理具有大量顶点的场景。但是，```在您通过每帧几何的某个阈值后，大多数 GPU 会非常严重地下降```。为了在低端硬件上运行，我们将每帧 30k 个三角形作为软上限。这可能有点保守，但请记住，某些类型的灯可以增加您的三角形数量！

还有一些其他的经验法则，但它们不太重要：上面的规则涵盖了 95% 的性能不佳的情况。其中，我想说与填充相关的放缓占绝大多数情况。

我们处理这些问题的策略也归结为一些规则：
1. (Macrotexture everything)宏观纹理一切。 宏观纹理是在场景中使用尽​​可能少的纹理的过程。Wind-up Knight 2中的关卡 都适合 4 个 1024×1024 纹理。由于多种原因，这很快，```但主要好处之一是它允许我们使用相同的纹理将所有可见几何图形批处理到单个 VBO 中，并一次将其发送到 GPU。Unity 通过其动态批处理 选项自动完成了这项工作。```宏观纹理化很难，它需要一位具有远见卓识的艺术家、认真的建模技巧，以及愿意重新加工事物以适应纹理变化的意愿。但这绝对值得。
2. 批量处理所有内容。 除了基于材质的动态批处理之外，我们还尝试组合我们知道不会移动的网格。Unity 称之为 静态批处理，它非常适合关卡几何体或其他从不移动的网格元素。```我们通常不会在编辑器中将场景设为静态，而是将所有可设为静态的对象标记为特定图层，然后使用 Unity 的 StaticBatchingUtility在关卡加载时组合静态网格物体。这会稍微增加加载时间，但会大大减少我们游戏二进制文件的大小。```
3. 控制绘图顺序.在 PC 上，您可能从后到前绘制场景，从天空盒开始，到离相机最近的位结束，然后是透明对象或其他需要混合的项目的通道。然而，在移动设备上，这会导致无法接受的透支量。```因此，我们尝试尽可能从前到后绘制，将天空盒和其他可能触及屏幕上大量像素的大型对象作为透明对象之前的最后一步绘制。用深度测试拒绝一个像素比多次不必要地填充该像素要快得多，因此不透明几何体的从前到后是一个巨大的胜利。```  
4. 注意透明度。  根据定义，透明度是多次填充像素的过程。因此，```在移动设备上，以半透明像素覆盖部分屏幕的大型对象非常昂贵。更糟糕的是透明层```。您可以避开屏幕的小区域，但是```一旦透明对象开始接触大量像素，帧时间成本就会很高```。我们尝试组织我们的透明对象，使重叠最小，并且它们在屏幕上占用尽可能少的像素。
5. 