---
layout: post
title:  "使用RenderTexture进行后处理"
image: ''
date:   2024-01-31 11:15:50
tags:
- Cocos
description: ''
categories: 
- Cocos
---
```lua
    local csbPath = "xxx.csb"
    local node = cc.CSLoader:createNode(csbPath)
    parent:addChild(node)
    node:setPosition(cc.p(display.cx,display.cy))

    local renderPost = app.Util:seekNodeByName(node,"renderPost")

    local format = cc.TEXTURE2_D_PIXEL_FORMAT_RGB_A8888
    --如果要截的图里面 需要绘制的节点中不需要深度缓冲和模板缓冲的话可以填0
    local depthStencilFormat = gl.DEPTH24_STENCIL8_OES
    local renderTexture = cc.RenderTexture:create(display.width,display.height,2,0x88F0)
    renderTexture:setAutoDraw(true)
    renderTexture:setClearColor(cc.c4f(0, 0, 0, 0))
    renderTexture:setClearFlags(GL_COLOR_BUFFER_BIT)
    renderPost:getParent():addChild(renderTexture)
    app.Util:changeParentToOther(renderPost,renderTexture,false)
    renderTexture:setLocalZOrder(-1)
    
    app.Util:shaderBlurEx(renderTexture:getSprite(),35)
```

1.  降低FBO切换频率,低端设备中FBO切换开销比较大。 
    使用AutoDraw每帧切换一次FBO的话,低端设备(小米4.4设备)上帧率会从60降低到20，
    可以改成在需要的时候开启(如果是静态图的话开启一次即可)。
2.  对于不需要模板和深度缓冲的情况下可以关闭模板和深度缓冲区。
    将0x88F0 改成0,即去掉模板和深度缓冲之后帧率会上升到26，

3. RT当中将传入的宽高当成精灵的大小又当成缓冲区的分辨率,实际上这是错误的
    因为帧缓冲区的分辨率是以实际像素为单位的,而精灵的宽高单位是设计分辨率下的坐标,缩放系数为设计分辨率/窗口分辨率。
    那么这个时候就会产生问题,如果传入的是设计分辨率下的宽高,那么帧缓冲区的大小就会浪费一部分。
    比如如果要创建一个全屏的RenderTexture,加入传入的宽高为 display.width,display.height,
    那么帧缓冲FBO的颜色缓冲区大小会比实际需要的大。  
4. 默认的帧缓冲的颜色缓冲区大小就是像素大小
5. RenderTexture 传递的宽高应该为像素分辨率,由此引发的精灵显示缩小问题可以设置精灵的scale属性放大一下。
但是当写入贴图到文件的时候,这个贴图使用的就是像素分辨率了,导致的结果就是不是1：1截图的情况,
不过问题不大,像素细节没有任何丢失。

