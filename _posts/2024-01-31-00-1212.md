---
layout: post
title:  "使用RenderTexture进行后处理"
image: ''
date:   2024-01-31 11:15:50
tags:
- Cocos
description: ''
categories: 
- Cocos
---
```lua
    local csbPath = "xxx.csb"
    local node = cc.CSLoader:createNode(csbPath)
    parent:addChild(node)
    node:setPosition(cc.p(display.cx,display.cy))

    local renderPost = app.Util:seekNodeByName(node,"renderPost")

    local format = cc.TEXTURE2_D_PIXEL_FORMAT_RGB_A8888
    --如果要截的图里面 需要绘制的节点中不需要深度缓冲和模板缓冲的话可以填0
    local depthStencilFormat = gl.DEPTH24_STENCIL8_OES
    local renderTexture = cc.RenderTexture:create(display.width,display.height,2,0x88F0)
    renderTexture:setAutoDraw(true)
    renderTexture:setClearColor(cc.c4f(0, 0, 0, 0))
    renderTexture:setClearFlags(GL_COLOR_BUFFER_BIT)
    renderPost:getParent():addChild(renderTexture)
    app.Util:changeParentToOther(renderPost,renderTexture,false)
    renderTexture:setLocalZOrder(-1)
    
    app.Util:shaderBlurEx(renderTexture:getSprite(),35)
```

1. GL_DEPTH24_STENCIL8 > 0  关闭深度和模板缓冲区,提升帧率
2. 将缓冲区的分辨率设置成像素分辨率
3. RT当中将传入的宽高当成精灵的大小又当成缓冲区的分辨率,实际上这是错误的
    因为帧缓冲区的分辨率是以实际像素为单位的,而精灵的宽高单位是设计分辨率下的坐标,缩放系数为设计分辨率/窗口分辨率。
    那么这个时候就会产生问题,如果传入的是设计分辨率下的宽高,那么帧缓冲区的大小就会浪费一部分。
    比如如果要创建一个全屏的RenderTexture,加入传入的宽高为 display.width,display.height,
    那么帧缓冲FBO的颜色缓冲区大小会比实际需要的大。  
4. 默认的帧缓冲的颜色缓冲区大小就是像素大小

5. RenderTexture 传递的宽高应该为像素分辨率,由此引发的精灵显示缩小问题可以设置精灵的scale属性放大一下。
但是当写入贴图到文件的时候,这个贴图使用的就是像素分辨率了,导致的结果就是不是1：1截图的情况，不过问题不大。

6. 当然如果非要传设计分辨率下的单位也是可以的,缺点就是需要申请一大块内存,低端设备容易出现崩溃

PS:
    1、如果窗口的分辨率<设计分辨率,那么1个像素单位对应多个坐标系的单位,即UI是经过缩小后投影到屏幕上的
    2、如果窗口分辨率>设计分辨率,那么多个像素单位对应一个坐标系单位,即UI是经过放大后投影到屏幕上的

    如果是第一种,使用Rt以及像素分辨率单位截图后,相对于屏幕的显示,像素细节并不会丢失(但是投影到屏幕的时候会存在一定情况的细节丢失)
    如果是第二种,是可以使用坐标系单位的,因为本身UI是经过插值的方式显示到屏幕上的,缩放后并不会丢失细节

