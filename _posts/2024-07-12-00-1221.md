---
layout: post
title:  "大音频边解边播"
image: ''
date:   2024-07-12 12:45:27
tags:
- Cocos
description: ''
categories: 
- Cocos
---

问题原因:
1、OpenSLES 自带的边解边播，刚播放就销毁会遇到底层解码线程死锁问题
```
09-19 15:19:31.833 E/libOpenSLES( 5795): frameworks/wilhelm/src/android/AudioPlayer_to_android.cpp:751: pthread_mutex_lock_timeout_np returned 110
09-19 15:19:31.833 W/libOpenSLES( 5795): frameworks/wilhelm/src/android/AudioPlayer_to_android.cpp:751: pthread 0xd67f0f80 (tid 6053) sees object 0xd67cf000 was locked by pthread 0xe45cf300 (tid 5888) at frameworks/wilhelm/src/itf/IObject.c:411
```
2、部分低内存设备以及某些写死了共享内存的华为PAD会出现共享缓冲区溢出的问题。

解决方案:
自己进行边解边播的处理。

OpenSLES 播放方式有两种,一种是播放url,一种是播放PCM数据。
播放PCM数据的时候是没有上面两个问题的,所以自己进行解码并传递PCM数据是可行的。

遇到的问题:
1. 重新采样问题
android设备支持率最高的是44.1K的采样率的音频,但是如果mp3是其他采样率的话就需要进行重新采样。
但是边解边播意味着无法对整体的PCM数据重采样,只能对一帧一帧的数据分别进行重采样,结果就是导致采样不均匀,会出现一些杂音(得得得得这样的杂音)。
所以最好的办法是直接将mp3文件的采样率转成44.1K。
2. 分离线程问题
当销毁音频的时候,如果用不分离的线程join等待的话,就必须等待当前正在解码的帧解码完才能退出,
某些低端的设备可能会出现一点轻微的卡顿情况。
所以最好的方案就是将解码线程内用到的音频对象的成员变量改成共享指针,这样就不用等待线程结束就可以直接销毁对象了。
3. 解码跟不上的问题
如果某些低端设备音频解码速度跟不上(绝大多数android设备都应该是可以跟上的),那么提供一些静默数据提供上去。
4. seek时间问题  
因为解码是异步的,所以假设要seek到1分钟进行播放,那么就需要从0秒开始一直解码到1分钟后才能完成播放.   
**这是目前的做法,因为seek时间的操作不多,而且seek范围不大**  


#### 目前的做法是   
解码到队列,播放的时候用一个index索引来获取PCM数据而不进行出队操作。
这样做的目的是方便获取当前播放的时间以及设置当前播放的时间。  
还有另一种方案就是,不保留队列中的PCM数据,播一个出队一个,  
但是这样在seek以及重播的时候就需要重新解码,  
那么就必须要知道给定的时间time 在mp3文件中的offset，然后从这个offset处开始解码。
但是目前这个步骤还没有理解清楚。嗯，TODO.

这种做法需要更多的内存,按照平均压缩率10:1的情况下。
最大音频大概在1M左右,而这种大文件要么是背景音乐要么是语音。
而语音和背景音乐基本都是同时只会播放一个,不用但因因为内存导致出现崩溃问题,20多M内存完全没啥问题。
所以这种方案在OTT上应该也是可以的。

PS:上线后android ARN率从0.4%直接降低到了0.2%