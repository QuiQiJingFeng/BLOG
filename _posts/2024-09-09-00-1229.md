---
layout: post
title:  "切后台操作的一些问题和优化方法"
image: ''
date:   2024-09-09 18:00:22
tags:
- Cocos
description: ''
categories: 
- Cocos
---
### 1、场景转换过程中切后台  
最完美的方案是在applicationDidEnterBackground中阻塞直到完成这一轮mainLoop。  
这就要求每帧的mainLoop时间必须控制在一定范围内,否则用户体验会比较差。

所以要控制渲染的时间片段,将渲染任务分成小片段，确保每个渲染任务都可以在短时间内完成。

1. 同步的网络请求应该尽可能的减少,因为在网络差的情况下,可能导致该帧消耗更多的时间。
2. 避免在单个渲染帧中进行大量的计算,如果有这种要求的话最好可以分帧计算。
3. 对于需要创建大量UI的场景,提前将合图进行分帧加载或者UI分帧创建,避免场景创建消耗大量时间


但是这种方案不太可控,原因是:
1. 不同的设备性能不一样
2. 随着应用的复杂性提升想要控制单个mainLoop的时间在一定范围就更加困难。  
3. 一些三方SDK消耗的时间以及一些场景涉及到多个模块等等。  

而一旦onPause被阻塞超过一定时间,系统会认为应用卡住并强制杀死应用或者显示“应用无响应”

### 2、异步回调时恰好在后台
1. 异步返回的时候要判断一下当前是否处于后台,处于后台的话就加入后台消息队列,等返回前台时再执行

PS:除了第一种方案可以完美解决外，其他的都无法完全避免问题的出现，只能降低概率。

### 常见的后台问题与 OpenGL API 的关系
#### 与绘图相关的 API

例如 **glDrawArrays**、**glDrawElements**，以及所有涉及绘制的调用在后台时最容易出问题。这是因为 OpenGL 的绘图操作依赖于有效的绘图表面（EGLSurface）和上下文。如果应用进入后台，通常绘图表面会被销毁或暂停，导致绘图调用失败。  

纹理、帧缓冲、着色器等资源的创建和管理

例如 **glGenTextures**、**glBindFramebuffer**、**glLinkProgram** 等调用可能不会立即崩溃，但当上下文失效时，资源的状态也可能无法正确保持。这些资源与 EGLContext 关联，后台状态可能会影响到这些资源的使用。  

状态修改调用

类似于 **glEnable**、**glDisable**、**glBlendFunc** 这样的调用修改 OpenGL 状态，虽然不涉及绘制，但如果上下文无效时，状态修改会失效，这可能导致在恢复前台后，状态不一致，导致后续的渲染出现问题。

也就是说即时包装openGL API,判断处于后台就让其失效也不行,因为纹理、帧缓冲、着色器创建失败的话,会影响之后的逻辑的，比如纹理创建失败后续逻辑都会出问题。