---
layout: post
title:  "IMGUI Leran 1"
image: ''
date:   2020-09-25 16:09:47
tags:
- IMGUI
description: ''
categories: 
- IMGUI
---
# IMGUI 学习

ImGui是为C++设计的,在一些语言的绑定上或多或少的存在一些缺少的内容，或者使用方式上有些差别,所以从C++开始学习是个明智的选择。

[其他语言的一些绑定](https://github.com/ocornut/imgui/wiki/Bindings)  

## 1. 创建一个视图
```c
#include "customTest.h"
#include "imgui.h"
static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title");
		ImGui::End();
	}
}
```
这段代码创建了一个视图，并且指定视图的标题为title  
![图片](..\assets\img\opengl\imgui_view.png)  

## 2. 创建一个Button
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1");
		if (ImGui::Button("Close Me"))
			is_open = false;
		ImGui::End();
	}
}
```
创建一个Button用来关闭视图，如果ImGui::Button("Close Me")返回true，说明这个按钮在上一帧被点击了，当按钮被点击之后,将bool值设置为false，那么下一帧的if就不会进来,进而整个view就不会被绘制。
![图片](..\assets\img\opengl\imgui_closev.png)  

```
--TODO 为什么即使绘制的按钮 能拿到上一帧的状态,靠什么来找呢,文字？Id?
```

### 3. 视图本身支持关闭按钮,即右上角可以加上关闭按钮,只需要在ImGui::Begin的时候多传一个参数即可
```c
#include "customTest.h"
#include "imgui.h"
static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title",&is_open);
		if (ImGui::Button("Close Me"))
			is_open = false;
		ImGui::End();
	}
}
```  
此时当视图的关闭按钮被点击之后,会修改is_open变量为false,  
然后下一帧就无法通过判断条件，进而不再绘制view.  

![图片](..\assets\img\opengl\imgui_close.png) 

### 4. 给视图中添加一个文本
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
		ImGui::Text("this is a custom window");
		if (ImGui::Button("Close Me"))
			is_open = false;
		ImGui::End();
	}
}
```
![图片](..\assets\img\opengl\imgui_text.png)  

视图中的两个元素的排列方式是,每个元素各占一行，这个是默认的排布方式。

### 5. 添加一个复选框
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
static bool check_select = false;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);   // Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)
		ImGui::Text("this is a custom windowt");
		if (ImGui::Button("Close Me"))
			is_open = false;
		ImGui::Checkbox("checkBox", &check_select);
		if (check_select)
			is_open = false;
		ImGui::End();
	}
}
```
复选框接受一个文本说明字符串以及一个开关变量check_select,  
如果check_select为true则为选中状态,如果为false，则是没有选中的状态
![图片](..\assets\img\opengl\imgui_cbx.png)  

### 6. 添加一个滑块
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
static bool check_select = false;
static float sliderValue = 0.0f;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
		ImGui::Text("this is a custom windowt");
		if (ImGui::Button("Close Me"))
			is_open = false;
		ImGui::Checkbox("checkBox", &check_select);
		if (check_select)
			is_open = false;

		ImGui::SliderFloat("slider", &sliderValue, 0.0f, 1.0f);
		if (sliderValue == 1)
			is_open = false;
		ImGui::End();
	}
}
```
添加了一个滑动条
参数1 指定了滑动条的文本
参数2 传入一个float类型的指针,用来接收当前的滑动值
参数3 参数4 指定了滑动条的滑动范围
最后我们根据滑动条的值进行处理,关闭视图
![图片](..\assets\img\opengl\imgui_slider.png)  

### 7. 添加一个颜色选择器
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
static bool check_select = false;
static float sliderValue = 0.0f;
static ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
		ImGui::Text("this is a custom windowt");
		if (ImGui::Button("Close Me"))
			is_open = false;
		ImGui::Checkbox("checkBox", &check_select);
		if (check_select)
			is_open = false;

		ImGui::SliderFloat("slider", &sliderValue, 0.0f, 1.0f);
		if (sliderValue == 1)
			is_open = false;

		ImGui::ColorEdit3("clear color", (float*)&clear_color);
		//因为浮点类型的原因,所以不能跟1直接比较,所以这里暂时这么写
		if (clear_color.x > 0.99 && clear_color.y > 0.99 && clear_color.z > 0.99)
			is_open = false;

		ImGui::End();
	}
}
```
颜色选择器接受一个文本以及一个ImVec4的指针,当颜色选择发生改变的时候会更新ImVec4变量的值，然后当颜色趋向于白色的时候关闭视图

![图片](..\assets\img\opengl\imgui_color_select.png)  

### 8. 让两个元素在同一行

```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
static bool check_select = false;
static float sliderValue = 0.0f;
static ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
		ImGui::Text("this is a custom windowt");
		if (ImGui::Button("Close Me"))
			is_open = false;

		ImGui::SameLine();  //告诉imgui 下一个元素跟上一个元素在同一行

		ImGui::Checkbox("checkBox", &check_select);
		if (check_select)
			is_open = false;

		ImGui::SliderFloat("slider", &sliderValue, 0.0f, 1.0f);
		if (sliderValue == 1)
			is_open = false;

		ImGui::ColorEdit3("clear color", (float*)&clear_color);
		//因为浮点类型的原因,所以不能跟1直接比较,所以这里暂时这么写
		if (clear_color.x > 0.99 && clear_color.y > 0.99 && clear_color.z > 0.99)
			is_open = false;

		ImGui::End();
	}
}
```
ImGui::SameLine  可以让其前后的两个元素处于同一行
![图片](..\assets\img\opengl\imgui_sample_line.png)  

### 9. 添加菜单栏
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
static bool check_select = false;
static float sliderValue = 0.0f;
static ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

void CustomTest::draw()
{
	
	

	if (is_open)
	{
		ImGui::Begin("title1", &is_open, ImGuiWindowFlags_MenuBar);

		if (ImGui::BeginMenuBar())
		{
			if (ImGui::BeginMenu("Menu"))
			{
				ImGui::MenuItem("1111", NULL, false, false);
				ImGui::EndMenu();
			}

			if (ImGui::BeginMenu("Examples"))
			{
				ImGui::MenuItem("2222", NULL, false, false);
				ImGui::EndMenu();
			}

			ImGui::EndMenuBar();
		}

		ImGui::End();
	}
}
```
开启菜单栏,需要在view创建的时候传入第三个参数ImGuiWindowFlags_MenuBar来开启view上的菜单栏。
方法|解释
:-|:-
ImGui::BeginMenuBar |菜单栏绘制开始
ImGui::EndMenuBar   |菜单栏绘制结束
ImGui::BeginMenu    |菜单栏选项绘制 参数为菜单选项名称
ImGui::EndMenu      |结束菜单栏选项绘制
![图片](..\assets\img\opengl\imgui_caidanlanitem.png)    

### 10. 绘制菜单选项中的元素

1. 可勾选的元素，类似于编辑器中的打开某个选项卡或者关闭某个选项卡之类的
```
ImGui::MenuItem("property", NULL, &property);
```
![图片](..\assets\img\opengl\imgui_xuanxiangyuansu_gouxuan1.png)  
![图片](..\assets\img\opengl\imgui_xuanxiangyuansu_gouxuan2.png)  

2. 嵌套选项
```c
if (ImGui::BeginMenuBar())
{
	if (ImGui::BeginMenu("Menu"))
	{
		ImGui::MenuItem("property", NULL, &property);
		if (ImGui::BeginMenu("Open Recent"))
		{
			ImGui::MenuItem("AAAAA");
			ImGui::MenuItem("BBBBB");
			ImGui::MenuItem("CCCCC");
			if (ImGui::BeginMenu("More.."))
			{
				ImGui::MenuItem("111111");
				ImGui::MenuItem("22222");
				if (ImGui::BeginMenu("More..."))
				{

					ImGui::EndMenu();
				}
				ImGui::EndMenu();
			}
			ImGui::EndMenu();
		}
		ImGui::EndMenu();
	}

	if (ImGui::BeginMenu("Examples"))
	{
		ImGui::MenuItem("2222", NULL, false, false);
		ImGui::EndMenu();
	}

	ImGui::EndMenuBar();
}
```
选项中的元素也可以是一个新的选项,可以构成类似于树的结构
![图片](..\assets\img\opengl\imgui_qiantaoxuanxiang.png)  


## 11. Radio 选项组
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);

		static int e = 0;
		ImGui::RadioButton("radio a", &e, 0); ImGui::SameLine();
		ImGui::RadioButton("radio b", &e, 1); ImGui::SameLine();
		ImGui::RadioButton("radio c", &e, 2);

		ImGui::End();
	}
}
```
![图片](..\assets\img\opengl\imgui_radio.png)  

## 12. smallButton 小按钮
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);

		
		
		if (ImGui::Button("button"))
			is_open = false;

		ImGui::SameLine();

		if (ImGui::SmallButton("smallButton"))
			is_open = false;

		ImGui::End();
	}
}
```
![图片](..\assets\img\opengl\imgui_small_btn.png)  

## 13. Separator 分割线
```c
ImGui::Separator();
```
![图片](..\assets\img\opengl\imgui_fengexian.png)  

## 14. 输出字符串到剪切板
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
		static bool toclip = true;
		if (toclip){
			toclip = false; //向剪切板发送,不能每帧都调用
			ImGui::LogToClipboard();
			ImGui::LogText("Hello, world!");
			ImGui::LogFinish();
		}
	
		ImGui::End();
	}
}
```

## 15. Tree

```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
		if (ImGui::TreeNode("AAA")){
			ImGui::Text("A");
			ImGui::TreePop();
		}

		if (ImGui::TreeNode("BBB")){
			ImGui::Text("B");
			ImGui::TreePop();
		}

		if (ImGui::TreeNode("CCC")){
			ImGui::Text("C");
			ImGui::TreePop();
		}
	
		ImGui::End();
	}
}
```

![图片](..\assets\img\opengl\imgui_tree.png)  


## 16. 下拉列表
```c
#include "customTest.h"
#include "imgui.h"
static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
		const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIIIIII", "JJJJ", "KKKKKKK" };
		static int item_current = 0;
		ImGui::Combo("combo", &item_current, items, IM_ARRAYSIZE(items));
		ImGui::End();
	}
}
```

![图片](..\assets\img\opengl\imgui_xialaliebiao.png)

## 17. 浮动的气泡
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
 
		ImGui::Text("(?)");
		//如果光标发生悬停
		if (ImGui::IsItemHovered())
		{
			ImGui::BeginTooltip();
			ImGui::Text("HP:300\nMP:100\nAP:1000\nSP:240");
			ImGui::EndTooltip();
		}
		 

		ImGui::End();
	}
}
```

![图片](..\assets\img\opengl\imgui_floatview.png)

## 18. 子弹文本 小圆点
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
		ImGui::BulletText("AAAAAAA");
		ImGui::BulletText("BBBBBBB");
		ImGui::Indent();
		ImGui::BulletText("11111111111111");
		ImGui::BulletText("22222222222222");
		ImGui::Indent();
		ImGui::BulletText("xxxxxxxxxxx");
		ImGui::BulletText("vvvvvvvvvvvvvv");
		ImGui::Unindent();
		ImGui::End();
	}
}
```

![图片](..\assets\img\opengl\imgui_xiaoyuandian.png)  


## 19. 带光标的多行文本输入框
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
 
		static char text[1024 * 16] =
			"/*\n"
			" The Pentium F00F bug, shorthand for F0 0F C7 C8,\n"
			" the hexadecimal encoding of one offending instruction,\n"
			" more formally, the invalid operand with locked CMPXCHG8B\n"
			" instruction bug, is a design flaw in the majority of\n"
			" Intel Pentium, Pentium MMX, and Pentium OverDrive\n"
			" processors (all in the P5 microarchitecture).\n"
			"*/\n\n"
			"label:\n"
			"\tlock cmpxchg8b eax\n";

		static ImGuiInputTextFlags flags = ImGuiInputTextFlags_AllowTabInput;
		// ImGuiInputTextFlags_ReadOnly  文本只读
		// ImGuiInputTextFlags_AllowTabInput 允许输入Tab键
		// ImGuiInputTextFlags_CtrlEnterForNewLine   Control+Enter换行
		ImGui::CheckboxFlags("ImGuiInputTextFlags_ReadOnly", (unsigned int*)&flags, ImGuiInputTextFlags_ReadOnly);
		ImGui::CheckboxFlags("ImGuiInputTextFlags_AllowTabInput", (unsigned int*)&flags, ImGuiInputTextFlags_AllowTabInput);
		ImGui::CheckboxFlags("ImGuiInputTextFlags_CtrlEnterForNewLine", (unsigned int*)&flags, ImGuiInputTextFlags_CtrlEnterForNewLine);
		ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-FLT_MIN, ImGui::GetTextLineHeight() * 16), flags);
 
		ImGui::End();
	}
}
```

![图片](..\assets\img\opengl\imgui_textarea.png)  


## 20. List
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
	
		const char* items[] = { "Apple", "Banana", "Cherry", "Kiwi", "Mango", "Orange", "Pineapple", "Strawberry", "Watermelon" };
		static int item_current = 1;
		ImGui::ListBox("listbox\n(single select)", &item_current, items, IM_ARRAYSIZE(items), 4);
 
		ImGui::End();
	}
}
```
![图片](..\assets\img\opengl\imgui_list.png)  

## 21. 单行输入框
```c
static char str0[128] = "Hello, world!";
ImGui::InputText("input text", str0, IM_ARRAYSIZE(str0));
```
![图片](..\assets\img\opengl\imgui_danhangshurukuang.png)  


## 22. 带加减号的输入框
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);
	
		//带加减号的输入框, 限制输入为 整形、浮点、双精度
		static int i0 = 123;
		ImGui::InputInt("input int", &i0);

		static float f0 = 0.001f;
		ImGui::InputFloat("input float", &f0, 0.01f, 1.0f, "%.3f");

		static double d0 = 999999.00000001;
		ImGui::InputDouble("input double", &d0, 0.01f, 1.0f, "%.8f");
 
		ImGui::End();
	}
}
```
![图片](..\assets\img\opengl\imgui_input_with_jiajian.png)  


## 23. 支持输入三个的输入框
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);

		static float vec4a[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
		ImGui::InputFloat3("input float3", vec4a);
 
		ImGui::End();
	}
}
```
![图片](..\assets\img\opengl\imgui_three_input.png)  


## 24. 横向滑动选择的的滑动条
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);

		enum Element { Element_Fire, Element_Earth, Element_Air, Element_Water, Element_COUNT };
		static int elem = Element_Fire;
		const char* elems_names[Element_COUNT] = { "Fire", "Earth", "Air", "Water" };
		const char* elem_name = (elem >= 0 && elem < Element_COUNT) ? elems_names[elem] : "Unknown";
		ImGui::SliderInt("slider enum", &elem, 0, Element_COUNT - 1, elem_name);
 
		ImGui::End();
	}
}
```
![图片](..\assets\img\opengl\imgui_hengxiangxuanze_enum.png) 

## 25. 显示图片
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);


		ImGuiIO& io = ImGui::GetIO();
		ImTextureID my_tex_id = io.Fonts->TexID;
		float my_tex_w = (float)io.Fonts->TexWidth;
		float my_tex_h = (float)io.Fonts->TexHeight;
		{
			ImGui::Text("%.0fx%.0f", my_tex_w, my_tex_h);
			ImVec2 uv_min = ImVec2(0.0f, 0.0f);                 // Top-left
			ImVec2 uv_max = ImVec2(1.0f, 1.0f);                 // Lower-right
			ImVec4 tint_col = ImVec4(0.0f, 1.0f, 1.0f, 1.0f);   // No tint     色调
			ImVec4 border_col = ImVec4(1.0f, 0.0f, 1.0f, 0.5f); // 50% opaque white  边框颜色
			ImGui::Image(my_tex_id, ImVec2(my_tex_w, my_tex_h), uv_min, uv_max, tint_col, border_col);
		}
		ImGui::End();
	}
}
```
![图片](..\assets\img\opengl\imgui_image.png)  

## 26. 可选择项
```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);

		static bool selection[5] = { false, true, false, false, false };
		ImGui::Selectable("1. I am selectable", &selection[0]);
		ImGui::Selectable("1. I am selectable", &selection[1],0,ImVec2(200,50));
		ImGui::Text("3. I am not selectable");
		ImGui::Selectable("4. I am selectable", &selection[3]);

		//双击模拟,传入的不是地址,所以Imgui内部不会改变这个变量,这样就可以从外部改变这个变量，从而达到双击的目的
		if (ImGui::Selectable("5. I am double clickable", selection[4], ImGuiSelectableFlags_AllowDoubleClick))
			if (ImGui::IsMouseDoubleClicked(0))
				selection[4] = !selection[4];
		ImGui::End();
	}
}
```

![图片](..\assets\img\opengl\imgui_selectable.png)  

## 27. 折线图、直方图、进度条

```c
#include "customTest.h"
#include "imgui.h"

static bool is_open = true;
void CustomTest::draw()
{
	if (is_open)
	{
		ImGui::Begin("title1", &is_open);

		//折线图, 横轴为时间,纵轴为指定的数值
		static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };
		ImGui::PlotLines("Frame Times", arr, IM_ARRAYSIZE(arr),20);


		//直方图
		ImGui::PlotHistogram("Histogram", arr, IM_ARRAYSIZE(arr), 0, NULL, 0.0f, 1.0f, ImVec2(0, 80.0f));


		// Animate a simple progress bar
		static float progress = 0.0f, progress_dir = 1.0f;
		 

		progress += progress_dir * 0.4f * ImGui::GetIO().DeltaTime;
		if (progress >= +1.1f) { progress = +1.1f; progress_dir *= -1.0f; }
		if (progress <= -0.1f) { progress = -0.1f; progress_dir *= -1.0f; }
		// Typically we would use ImVec2(-1.0f,0.0f) or ImVec2(-FLT_MIN,0.0f) to use all available width,
		// or ImVec2(width,0.0f) for a specified width. ImVec2(0.0f,0.0f) uses ItemWidth.
		ImGui::ProgressBar(progress, ImVec2(0.0f, 0.0f));
		ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
		ImGui::Text("Progress Bar");

		ImGui::End();
	}
}
```

![图片](..\assets\img\opengl\imgui_jindu.png)  

## 28. 竖直方向的滑动条
```c
static int int_value = 0;
ImGui::VSliderInt("##int", ImVec2(18, 160), &int_value, 0, 5);
```

## 29.