---
layout: post
title:  "shader 使用滚筒实现翻页"
image: ''
date:   2023-10-18 18:11:07
tags:
- Shader
description: ''
categories: 
- Shader
---
[参考文档](https://andrewhungblog.wordpress.com/2018/04/29/page-curl-shader-breakdown/)
卷页着色器细分
卷页是电子阅读器应用中相当常见的效果。它看起来像这样：
![图片](..\assets\img\shader\turn1.jpg) 

该效果背后的基本思想是，页面的卷曲被表示为一个圆柱体，其左右边缘平行于我所说的“卷曲轴”。卷曲轴是沿着卷曲底部折叠页面时得到的折痕： 
![图片](..\assets\img\shader\turn2.png)  
每个页面（当前页面和下一页）都表示为传递到着色器的不同纹理。在片段着色器中，分析片段的位置以确定其相对于圆柱体和卷曲轴的位置。此信息用于确定要使用哪个纹理以及该纹理上要在片段位置显示的 UV 坐标。
这给了我们两个需要解决的子问题：
1. 找到圆柱体的位置和方向。
2. 根据 #1 和当前片段位置确定纹理和 UV

### #1：找到卷曲轴和圆柱体  
为了使四边形围绕圆柱体变形，我们需要知道圆柱体的实际位置和方向。这些信息可以用多种形式表示，因此考虑如何在子问题#2中使用这些信息来确定我们需要它的形式是有帮助的。我们需要的关键信息是当前片段有 多远是从旋度轴。这个距离本身就为我们提供了在子问题 #2 中选择正确纹理和映射 UV 所需的大部分信息，因此我们无需担心找到圆柱体的旋转角度或类似的问题。以下是我们在此步骤中尝试查找的信息的说明（从现在起我们将其称为d ）：  
![图片](..\assets\img\shader\turn3.png)  
查找 d涉及几个不同的步骤。让我们一步一步来。  

首先，我们希望以一种易于求解 d的方式表示旋度轴的方向。为此，我们可以简单地查看用户拖动屏幕的方向。如果我们找到用户将手指放在屏幕上的点（我们称之为clickPos ） 和他当前拖动手指的点（我们称之为DragPos）之间的向量，我们可以处理卷曲axis 是垂直于该向量并穿过 DragPos 的线。请参阅这些图像，直观地了解为什么这会成为良好的卷曲轴：
![图片](..\assets\img\shader\turn4.png)  
A是clickPos，B是dragPos
我们将计算方向向量 ( dir )，如下所示：
```c
vec2 dir = normalize(clickPos - dragPos);
```

现在我们需要弄清楚如何将片段 ( f ) 表示为向量，以便点积实际上为我们提供沿向量到旋度轴的投影长度。换句话说，我们需要找到如下所示的原点：  
![图片](..\assets\img\shader\turn5.png)  

f是任意片段
为了找到该点，我们可以计算页面左侧与来自DragPos的方向向量的交集： 
```c
vec2 origin = clamp(dragPos - dir * dragPos.x / dir.x, 0., 1.);
```
基本上，我们要找出有多少个dir实例适合在 DragPos和屏幕左侧之间。然后我们减去dir的多个实例，就到达了那个边缘。我们到达的点就是我们要寻找的原点。然后我们可以通过简单地从片段位置中减去原点来找到表示f的向量 。
现在我们有了片段和方向向量，我们可以采用点积来获得沿方向向量的距离。
```c
float distOfFragmentAlongDirectionVector = dot(fragVec, dir);
```
为了获得第 2 部分所需的关键信息（片段与卷曲轴的距离），我们可以进行以下计算：  
```c
float distOfFragmentFromCurlAxis = distOfFragmentAlongDirectionVector - distOfCurlAxisAlongDirectionVector;
```
由于我们使用dragPos 作为卷曲轴位置，因此之前计算的dragPos 和原点之间的距离为我们提供了 distOfCurlAxisAlongDirectionVector。distOfFragmentAlongDirectionVector是我们刚刚通过点积计算得出的投影距离。现在我们有了执行减法所需的两项，并找到片段与旋度轴的距离，这是我们继续解决子问题 #2 所需的。

### #2：将点映射到圆柱体
获得当前片段与卷曲轴之间的距离后，我们现在可以沿着圆柱体对图像进行适当的变形。现在存在三种情况将决定如何执行变形计算。这些场景取决于步骤 1 中计算的距离以及页面卷曲圆柱体的预配置半径。我将快速总结下面这三种情况，然后进行更详细的介绍：
1. 片段位于卷曲轴前方且不在卷曲半径内
2. 片段位于卷曲轴之前但在卷曲半径内
3. 片段位于卷曲轴后面
##### 场景 1：片段位于卷曲轴前方且不在半径内
从侧面看，这个场景是这样的：  
![图片](..\assets\img\shader\turn6.png)  
在这种情况下，很明显该点根本不在卷曲上，而是完全在第二页上。因此我们可以简单地对第二页的纹理进行采样，而根本不会使 UV 坐标变形。  

##### 场景 2：片段位于卷曲轴前方且在卷曲半径内  
如果我们位于旋度轴之前但在旋度半径内，则意味着我们位于旋度本身上。在这种情况下，我们肯定在第一页，但我们可以在页面的正面或背面。这个场景是这样的：
![图片](..\assets\img\shader\turn7.png)  
p1和p2表示片段在页面上的可能位置。p1位于页面的正面，p2 位于页面的背面，因为它向后卷曲并且观看者向下看页面。
为了找到p1和p2代表的实际 UV 坐标，我们基本上可以“展开”卷曲，看看如果页面平放，p1和p2会在哪里。我们可以通过计算从卷曲轴到该点沿圆周的距离来展开它。这就是几何和三角的用武之地。  
![图片](..\assets\img\shader\turn8.png)   
![图片](..\assets\img\shader\turn9.png)    
现在我们已经解决了d1和 d2 ，我们可以通过将 d1 和 d2 乘以 dir并将每个乘积添加到片段的方向向量与旋度相交的点来找到展开的p1 和 p2 的值axis（我们将这个点称为linePoint – 您可以通过dir * distOfFragmentFromCurlAxis将片段位置向curlAxis 移动来找到它，其中后一个变量是我们在子问题#1 中找到的关键信息）。

vec2 linePoint = fragmentPos - distOfFragmentFromCurlAxis * dir;
vec2 p1 = linePoint + dir * d1;
vec2 p2 = linePoint + dir * d2;

为了确定是使用p1（正面）还是p2（背面），我们只需检查p2处的 UV 坐标是否在 [0, 1] 的 UV 范围内。如果它在这些边界之外，则p2实际上根本不存在于第一页上，因此我们使用p1作为 UV 坐标。请参见下图，直观地了解为什么这是有意义的： 
![图片](..\assets\img\shader\turn10.png)  
在上图中，我们查看了 几个片段的展开p2 值。由于页面是矩形，因此一些展开的点将超出页面边界。对于这些片段，我们将使用 p1而不是 p2来获取 UV 坐标，因为 p2不再位于页面上。  
##### 场景 3：片段位于卷曲轴后面  
下面是场景 3 的可视化，假设卷曲的页面一旦位于卷曲轴后面就是直的： 
![图片](..\assets\img\shader\turn11.png)  

我们可以使用与场景 #2 类似的技术找到 UV——展开页面并查看该点位于展开页面上的位置。如果展开点位于 UV 边界 [0, 1] 内，则我们将其用作 UV。否则我们只使用片段的原始 UV。在这种情况下，找到展开的 UV 会更容易一些，因为我们不必执行任何三角操作 - 我们只需将片段与卷曲轴的距离加上周长的一半即可获得到p的距离（这真是太棒了）我们在第一个子问题中计算的数字）。
与前面的场景一样，如果页面背面的 UV 坐标超出范围，我们会忽略它，而只使用原始 UV。

### 杂项调整

现在你就得到了它。要查看具体的实现细节，请随时查看我的[Shadertoy](https://www.shadertoy.com/view/ls3cDB) 实现。据我所知，这已经是最简单的效果了（整个过程不到 50 行代码）。没有疯狂的网格变形或极其复杂的数学——只有一个带有一点三角函数的四边形。