---
layout: post
title:  "记录下开发中遇到的崩溃问题"
image: ''
date:   2020-09-30 09:56:59
tags:
- Cocos
description: ''
categories: 
- Cocos
---
# 记录下开发中遇到的崩溃问题

## 问题1:
报错信息
[Failed to get Java stack] 无法获取到java栈  

**FileUtils的isFileExist判断不生效**  
某些手机系统上会认为文件夹也是文件从而返回true,而且文件夹本身也是有大小的，从而导致java端报错，JNI引用表无法释放，最终累计导致java堆栈溢出
***

## 问题2
报错信息
[Failed to get Java stack]
JNI ERROR (app bug): local reference table overflow (max=512)  
JNI 引用数量超过最大限制,局部引用表溢出  
在Android中局部引用表默认最大容量是512个(现在一般都1024，但是还是有些低端机器是512)  
 
局部引用:
局部引用会阻止GC回收所引用的对象,并且在Native函数返回之后所引用的对象会在下次GC的时候被回收，也可以通过DeleteLocalRef来回收。

所以如果JNI调用频率比较低的话，即使不手动DeleteLocalRef其实也是没有问题的,GC会处理掉。
但是GC的时机是不受我们控制的,即使手动调用System.gc(); 也不能立刻让程序立刻就回收内存。这个调用相当于“建议”执行垃圾回收，但是什么时候调用是不能确定的！  

所以这就会出现一个问题,在gc回收前，如果引用的对象超过了最大限制就会发生闪退的情况。
所以必须手动对引用进行释放，防止溢出。


假设lua中注册了一个java的回调,然后回调中处理了大量的逻辑，导致方法没有返回,那么这次调用产生的局部引用就不会被及时释放。
尤其是大量调用，比如循环的时候更容易出现这种问题

本质原因是引用表溢出,表现形式有以下几种  
1. 调用结束之后没有解除局部引用
2. C->JAVA, JAVA报错(JAVA报错不会导致闪退而且不会返回C层,所以会发生泄漏)没有返回导致引用没有被释放
3. JAVA->C, C->JAVA, JAVA->C ...
例如:
	audio:play(xxx,function() 
		audio:play(xxx,function() 
			audio:play(xxx,function() 
				...
			end)
		end)
	end)
这种因为回调方法没有执行完,所以相应的引用表没有被释放,所以越积越多

参考:  
1. https://segmentfault.com/a/1190000015583877
2. https://blog.csdn.net/xyang81/article/details/44873769

***