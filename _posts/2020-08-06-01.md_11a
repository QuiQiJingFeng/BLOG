---
layout: post
title:  "OpenGL 变换"
image: ''
date:   2020-08-06 10:28:55
tags:
- OpenGL
description: ''
categories: 
- OpenGL
---
#### [教程链接](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)
# 变换

## 向量
> 向量最基本的定义就是一个方向。或者更正式的说，向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。  
下面你会看到3个向量，每个向量在2D图像中都用一个箭头(x, y)表示。  
我们在2D图片中展示这些向量，因为这样子会更直观一点。  
你可以把这些2D向量当做z坐标为0的3D向量。  
**由于向量表示的是方向，起始于何处并不会改变它的值。**  
下图我们可以看到向量v¯和w¯是相等的，尽管他们的起始点不同：
![图片](..\assets\img\opengl\vectors.png)  
**数学家喜欢在字母上面加一横表示向量，比如说v¯。**  
当用在公式中时它们通常是这样的：  
![图片](..\assets\img\opengl\xiangliang.png)   
**由于向量是一个方向，所以有些时候会很难形象地将它们用位置(Position)表示出来。为了让其更为直观，我们通常设定这个方向的原点为(0, 0, 0)，然后指向一个方向，对应一个点，使其变为位置向量(Position Vector) 
(你也可以把起点设置为其他的点，然后说：这个向量从这个点起始指向另一个点）。比如说位置向量(3, 5)在图像中的起点会是(0, 0)，并会指向(3, 5)**

## 向量与标量运算
> 标量(Scalar)只是一个数字（或者说是仅有一个分量的向量）。  
当把一个向量加/减/乘/除一个标量，我们可以简单的把向量的每个分量分别进行该运算。对于加法来说会像这样:  
![图片](..\assets\img\opengl\xiangliang_jia_biaoliang.png)  
__其中的+可以是+，-，·或÷，其中·是乘号。注意－和÷运算时不能颠倒（标量-/÷向量），因为颠倒的运算是没有定义的__
> ```
> 注意，数学上是没有向量与标量相加这个运算的，但是很多线性代数的库都对它有支持（比如说我们用的GLM）。如果你使用过numpy的话，可以把它理解为Broadcasting。
> ```

## 向量取反
> __对一个向量取反(Negate)会将其方向逆转。一个指向东北的向量取反后就指向西南方向了。我们在一个向量的每个分量前加负号就可以实现取反了（或者说用-1数乘该向量）:__
> ![图片](..\assets\img\opengl\xiangliangqufan.png)

## 向量加减
> __向量的加法可以被定义为是分量的(Component-wise)相加，即将一个向量中的每一个分量加上另一个向量的对应分量：__
> ![图片](..\assets\img\opengl\xiangliang_xiangjia.png)
> **向量v = (4, 2)和k = (1, 2)可以直观地表示为：**  
> ![图片](..\assets\img\opengl\vectors_addition.png)  
__就像普通数字的加减一样，向量的减法等于加上第二个向量的相反向量：__  
![图片](..\assets\img\opengl\xiangliang_xiangjian.png)
__两个向量的相减会得到这两个向量指向位置的差。这在我们想要获取两点的差会非常有用__  
![图片](..\assets\img\opengl\vectors_subtraction.png)

## 长度
> __我们使用勾股定理(Pythagoras Theorem)来获取向量的长度(Length)/大小(Magnitude)。如果你把向量的x与y分量画出来，该向量会和x与y分量为边形成一个三角形:__  
![图片](..\assets\img\opengl\vectors_triangle.png)  
因为两条边（x和y）是已知的，如果希望知道斜边v¯的长度，我们可以直接通过勾股定理来计算：
![图片](..\assets\img\opengl\gougudingli.png)  
**有一个特殊类型的向量叫做单位向量(Unit Vector)。**  
**单位向量有一个特别的性质——它的长度是1。**  
**我们可以用任意向量的每个分量除以向量的长度得到它的单位向量n^：**
![图片](..\assets\img\opengl\danweixiangliang.png)  
我们把这种方法叫做一个**向量的标准化(Normalizing)**。  
单位向量头上有一个^样子的记号。  
通常单位向量会变得很有用，特别是在我们只关心方向不关心长度的时候（如果改变向量的长度，它的方向并不会改变）。

## 向量相乘
> 两个向量相乘是一种很奇怪的情况。普通的乘法在向量上是没有定义的，因为它在视觉上是没有意义的。  
但是在相乘的时候我们有两种特定情况可以选择：  
__一个是点乘(Dot Product)，记作v¯⋅ k¯，另一个是叉乘(Cross Product)，记作v¯× k¯。__
>### 点乘
>__两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。__
可能听起来有点费解，我们来看一下公式：  
__v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ__  
它们之间的夹角记作θ。  
为什么这很有用？  
想象如果v¯和k¯都是单位向量，它们的长度会等于1。这样公式会有效简化成：  
__v¯⋅k¯=1⋅1⋅cosθ=cosθ__  

> 你也可以通过点乘的结果计算两个非单位向量的夹角，点乘的结果除以两个向量的长度之积，得到的结果就是夹角的余弦值，即cosθ。
> 译注：通过上面点乘定义式可推出：
> cosθ = v¯⋅k¯ / ||v¯||⋅||k¯||

> 所以，我们该如何计算点乘呢？点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。两个单位向量的（你可以验证它们的长度都为1）点乘会像是这样：  
![图片](..\assets\img\opengl\diancheng.png)
**要计算两个单位向量间的夹角，我们可以使用反余弦函数cos−1 ，可得结果是143.1度。现在我们很快就计算出了这两个向量的夹角。点乘会在计算光照的时候非常有用。**
>***
> ### 叉乘
> **叉乘只在3D空间中有定义**  
>* **它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量**  
>* **如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量**  

> 接下来的教程中这会非常有用。下面的图片展示了3D空间中叉乘的样子：  
![图片](..\assets\img\opengl\vectors_crossproduct.png)  
不同于其他运算，如果你没有钻研过线性代数，可能会觉得叉乘很反直觉，所以只记住公式就没问题啦（记不住也没问题）。下面你会看到两个正交向量A和B叉积： 
>![图片](..\assets\img\opengl\chaji.png)
__是不是看起来毫无头绪？不过只要你按照步骤来了，你就能得到一个正交于两个输入向量的第三个向量。__

## 矩阵
>现在我们已经讨论了向量的全部内容，是时候看看矩阵了！简单来说矩阵就是一个矩形的数字、符号或表达式数组。矩阵中每一项叫做矩阵的元素(Element)。  
下面是一个2×3矩阵的例子：  
![图片](..\assets\img\opengl\2_3_juzhen.png)  
__矩阵可以通过(i, j)进行索引，i是行，j是列，这就是上面的矩阵叫做2×3矩阵的原因（3列2行，也叫做矩阵的维度(Dimension)）__  
__这与你在索引2D图像时的(x, y)相反，获取4的索引是(2, 1)（第二行，第一列）__  
__译注：如果是图像索引应该是(1, 2)，先算列，再算行__ 
__矩阵基本也就是这些了，它就是一个矩形的数学表达式阵列。和向量一样，矩阵也有非常漂亮的数学属性。矩阵有几个运算，分别是：矩阵加法、减法和乘法__
>*** 
> ### 矩阵与标量之间的加减
![图片](..\assets\img\opengl\juzhenjiafa.png)  
![图片](..\assets\img\opengl\juzhenjianfa.png)  
> ```
> 注意，数学上是没有矩阵与标量相加减的运算的，但是很多线性代数的库都对它有支持（比如说我们用的GLM）。如果你使用过numpy的话，可以把它理解为Broadcasting。
>```
> ### 矩阵与矩阵的加减 
> __矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。__  
__这也就是说加法和减法只对同维度的矩阵才是有定义的。__
__一个3×2矩阵和一个2×3矩阵（或一个3×3矩阵与4×4矩阵）是不能进行加减的__
![图片](..\assets\img\opengl\juzhen_jia_juzhen.png)  
![图片](..\assets\img\opengl\juzhen_jian_juzhen.png)
> ***
> ### 矩阵的数乘
> __和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的每一个元素分别乘以该标量。下面的例子展示了乘法的过程：__  
![图片](..\assets\img\opengl\juzhen_shucheng.png)
> __现在我们也就能明白为什么这些单独的数字要叫做标量(Scalar)了。  
简单来说，标量就是用它的值缩放(Scale)矩阵的所有元素（译注：注意Scalar是由Scale + -ar演变过来的）。  
前面那个例子中，所有的元素都被放大了2倍。__

### 矩阵相乘
> **矩阵之间的乘法不见得有多复杂，但的确很难让人适应。矩阵乘法基本上意味着遵照规定好的法则进行相乘。当然，相乘还有一些限制：**  
> * **只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘**
> * **矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅A**  
> #### 我们先看一个两个2×2矩阵相乘的例子:  
>![图片](..\assets\img\opengl\juzhenxiangcheng.png)  
> 左侧矩阵的行 * 右侧矩阵的列
> * [左矩阵第一行 * 右矩阵第一列  左矩阵第一行 * 右矩阵第二列]
> * [左矩阵第二行 * 右矩阵第一列  左矩阵第二行 * 右矩阵第二列]
> ***
> ### 矩阵与向量相乘
> #### 单位矩阵
> 在OpenGL中，由于某些原因我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。我们能想到的最简单的变换矩阵就是单位矩阵(Identity Matrix)。单位矩阵是一个除了对角线以外都是0的N×N矩阵。在下式中可以看到，这种变换矩阵使一个向量完全不变：  
![图片](..\assets\img\opengl\juzhenchengxiangliang.png)  
> 向量看起来完全没变。从乘法法则来看就很容易理解来：第一个结果元素是矩阵的第一行的每个元素乘以向量的每个对应元素。因为每行的元素除了第一个都是0，可得：1⋅1+0⋅2+0⋅3+0⋅4=1，向量的其他3个元素同理。  
> 单位矩阵通常是生成其他变换矩阵的起点，如果我们深挖线性代数，这还是一个对证明定理、解线性方程非常有用的矩阵。

***
***
> ## 缩放
> **对一个向量进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变** 
> 由于我们进行的是2维或3维操作，我们可以分别定义一个有2或3个缩放变量的向量，每个变量缩放一个轴(x、y或z)。  
我们先来尝试缩放向量v¯=(3,2)。我们可以把向量沿着x轴缩放0.5，使它的宽度缩小为原来的二分之一；我们将沿着y轴把向量的高度缩放为原来的两倍。我们看看把向量缩放(0.5, 2)倍所获得的s¯是什么样的：  
![图片](..\assets\img\opengl\vectors_scale.png)  
__我们刚刚的缩放操作是不均匀(Non-uniform)缩放，因为每个轴的缩放因子(Scaling Factor)都不一样。如果每个轴的缩放因子都一样那么就叫均匀缩放(Uniform Scale)。__  
> * 从图中可以看到,均匀缩放不改变原向量的方向,只改变大小
> * 不均与缩放会改变向量的方向  
> #### 我们下面会构造一个变换矩阵来为我们提供缩放功能。  
> 我们从单位矩阵了解到，每个对角线元素会分别与向量的对应元素相乘。  
如果我们把1变为3会怎样？这样子的话，我们就把向量的每个元素乘以3了，这事实上就把向量缩放3倍。  
如果我们把缩放变量表示为(S1,S2,S3)我们可以为任意向量(x,y,z)定义一个缩放矩阵：  
![图片](..\assets\img\opengl\suofangjuzhen.png)
__注意，第四个缩放向量仍然是1，因为在3D空间中缩放w分量是无意义的。w分量另有其他用途，在后面我们会看到。__  
> **这个矩阵对X轴缩放S1,Y轴缩放S2,Z轴缩放S3**
> ***
> ## 位移
> **位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量**
> 和缩放矩阵一样，在4×4矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是第四列最上面的3个值。如果我们把位移向量表示为(Tx,Ty,Tz)，我们就能把位移矩阵定义为：
![图片](..\assets\img\opengl\xiangliangweiyi.png)
因为位移是加减法运算,所以必须要有第四个分量,这就是为啥矩阵是4 * 4而不是3 * 3的原因。
> ```
> 齐次坐标(Homogeneous Coordinates)
> 向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。  
> 我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。
> 如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。
> ```
>__当向量的w分量为0，也就意味着Tx Ty Tz都等于0， 自然就无法进行位移了.__  
>__所以通过判断w分量是否为1,可以判断出来到底是向量还是点__  
>__有了位移矩阵我们就可以在3个方向(x、y、z)上移动物体，它是我们的变换工具箱中非常有用的一个变换矩阵__
> ***
> ## 旋转
> 上面几个的变换内容相对容易理解，在2D或3D空间中也容易表示出来，但旋转(Rotation)稍复杂些。  
[矩阵旋转证明过程](https://wiki.jikexueyuan.com/project/modern-opengl-tutorial/tutorial7.html)
> 首先我们来定义一个向量的旋转到底是什么。2D或3D空间中的旋转用角(Angle)来表示。角可以是角度制或弧度制的，周角是360角度或2 PI弧度。我个人更喜欢用角度，因为它们看起来更直观。
> 大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：  
弧度转角度：角度 = 弧度 * (180.0f / PI)  
角度转弧度：弧度 = 角度 * (PI / 180.0f)  
PI约等于3.14159265359。  
> 转半圈会旋转360/2 = 180度，向右旋转1/5圈表示向右旋转360/5 = 72度。下图中展示的2D向量v¯是由k¯向右旋转72度所得的：  
![图片](..\assets\img\opengl\vectors_angle.png)  
> 在3D空间中旋转需要定义一个角和一个旋转轴(Rotation Axis)。物体会沿着给定的旋转轴旋转特定角度。如果你想要更形象化的感受，可以试试向下看着一个特定的旋转轴，同时将你的头部旋转一定角度。当2D向量在3D空间中旋转时，我们把旋转轴设为z轴（尝试想象这种情况）。  
使用三角学，给定一个角度，可以把一个向量变换为一个经过旋转的新向量。  
这通常是使用一系列正弦和余弦函数（一般简称sin和cos）各种巧妙的组合得到的。  
当然，讨论如何生成变换矩阵超出了这个教程的范围。  
旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用θ表示：
![图片](..\assets\img\opengl\juzhenxuanzhuan.png)
> 利用旋转矩阵我们可以把任意位置向量沿一个单位旋转轴进行旋转。也可以将多个矩阵复合，比如先沿着x轴旋转再沿着y轴旋转。 
> #### 但是这会很快导致一个问题——万向节死锁（Gimbal Lock，可以看看这个视频[优酷](https://v.youku.com/v_show/id_XNzkyOTIyMTI=.html)来了解
> #### 在这里我们不会讨论它的细节，但是对于3D空间中的旋转，一个更好的模型是沿着任意的一个轴，比如单位向量$(0.662, 0.2, 0.7222)$旋转，而不是对一系列旋转矩阵进行复合。这样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中(Rx,Ry,Rz)代表任意旋转轴：
> ![图片](..\assets\img\opengl\chaojixuanzhuanjuzhen.png)
> 在数学上讨论如何生成这样的矩阵仍然超出了本节内容。但是记住，即使这样一个矩阵也不能完全解决万向节死锁问题（尽管会极大地避免）。避免万向节死锁的真正解决方案是使用四元数(Quaternion)，它不仅更安全，而且计算会更有效率。四元数可能会在后面的教程中讨论。  

>## 矩阵的组合
> 使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。  
让我们看看我们是否能生成一个变换矩阵，让它组合多个变换。  
假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。  
我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样：  
![图片](..\assets\img\opengl\weiyijiasuofang.png)  
* **注意，当矩阵相乘时我们先写位移再写缩放变换的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。**  
* **当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法**  
* **建议您在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响。** 
比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！  
用最终的变换矩阵左乘我们的向量会得到以下结果：**  
![图片](..\assets\img\opengl\xuanzhuanjiasuofang2.png)  
__向量先缩放2倍，然后位移了(1, 2, 3)个单位。__

> ## 实践
> 现在我们已经解释了变换背后的所有理论，是时候将这些知识利用起来了。OpenGL没有自带任何的矩阵和向量知识，所以我们必须定义自己的数学类和函数。在教程中我们更希望抽象所有的数学细节，使用已经做好了的数学库。幸运的是，有个易于使用，专门为OpenGL量身定做的数学库，那就是GLM。
> ***
> ## GLM
> ***
> GLM是OpenGL Mathematics的缩写，它是一个只有头文件的库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的网站上下载。把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。  
>[GLM 0.99](../lib/glm.rar)
> #### 我们需要的GLM的大多数功能都可以从下面这3个头文件中找到
>```c
>#include <glm/glm.hpp>
>#include <glm/gtc/matrix_transform.hpp>
>#include <glm/gtc/type_ptr.hpp>
>```
> 首先我们把箱子逆时针旋转90度。然后缩放0.5倍，使它变成原来的一半大。我们先来创建变换矩阵：
>```c
> glm::mat4 trans;
> trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));
> trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));
>```
> #### 我们把箱子在每个轴都缩放到0.5倍，然后沿z轴旋转90度。  
> #### GLM希望它的角度是弧度制的(Radian)，所以我们使用glm::radians将角度转化为弧度。
> #### 注意有纹理的那面矩形是在XY平面上的，所以我们需要把它绕着z轴旋转。
> #### 因为我们把这个矩阵传递给了GLM的每个函数，GLM会自动将矩阵相乘，返回的结果是一个包括了多个变换的变换矩阵。
> 然后在顶点着色器中添加一个mat4的uniform变量,之后用矩阵uniform * 位置变量
> ```c
> #version 330 core
> layout (location = 0) in vec3 aPos;
> layout (location = 1) in vec3 aColor;
> layout (location = 2) in vec2 aTexCoord;
> 
> out vec3 ourColor;
> out vec2 TexCoord;
> uniform mat4 transform;  //变换矩阵
> 
> void main()
> {
>     gl_Position = transform * vec4(aPos, 1.0);
>     ourColor = aColor;
>     TexCoord = aTexCoord;
> }
> ```
> 最后我们将矩阵传给着色器
> ```c
> unsigned int transformLoc = glGetUniformLocation(ourShader.ID, "transform");
> glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));
>```
> ![图片](..\assets\img\opengl\transformations.png)  
> #### 完美！我们的箱子向左侧旋转，并是原来的一半大小，所以变换成功了。我们现在做些更有意思的，看看我们是否可以让箱子随着时间旋转，我们还会重新把箱子放在窗口的右下角。要让箱子随着时间推移旋转，我们必须在游戏循环中更新变换矩阵，因为它在每一次渲染迭代中都要更新。我们使用GLFW的时间函数来获取不同时间的角度：
> ```c
> glm::mat4 trans;
> trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
> trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
> ```
> 结果:
>![图片](..\assets\img\opengl\xuanzhuan_jia_pingyi.gif)
> 如果我们改成 先平移后旋转 __(写法应该是先旋转后平移)__
> ```c
> glm::mat4 trans;
> trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));
> trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
> ```
>![图片](..\assets\img\opengl\pingyi_jia_xuanzhuan.gif)