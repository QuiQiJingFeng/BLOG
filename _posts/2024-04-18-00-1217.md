---
layout: post
title:  "cocos 显示摄像头画面遇到的一些问题"
image: ''
date:   2024-04-18 14:08:17
tags:
- Cocos
description: ''
categories: 
- Cocos
---
1. 前置摄像头画面左右相反
    前置摄像头的画面应该跟镜面一样的效果,但是android/ios都是相反的画面,所以做一个沿Y轴反转处理。
2. 充电口左右方向的两种横屏摄像头画面没有跟随旋转
    cocos的画面允许上下反转的情况下,需要获取设备是否反转,然后对摄像头画面旋转180度处理
3. 权限问题
    如果用户第一次拒绝了权限之后,第二次就无法请求权限,所以需要再第二次请求权限失败后弹框引导跳转设置界面的权限界面
4. 摄像头数据格式问题
    IOS和Android的YUV420格式选择后,最终给到的数据却都是YUV422的数据。
    所以需要按照YUV422的格式来处理。 
    其中Y是单独的一块数据,存储着YYYYYY
    UV是连在一起的数,存储着UVUVUV这样的数据
5. android 某些设备的某些预览大小跟最后返回的数据的大小不一致导致画面显示成横条
    ```java
    //使用真实返回数据的宽度
    int realWidth = image.getPlanes()[0].getRowStride();
    ```
6. android 如果某些设备的真实数据宽度跟预览宽度不一致，就会在边缘出现绿色的线条
    由于真实返回的数据宽度发生了变化(变大),但是高度没有发生变化,导致一部分数据被填充到了行的末尾。
    即[0,previewWidth)是有数据的，而[previewWidth,stride)补上的Y、UV均为0。
    补充的数据显示出来就是绿色的。

    11111100
    11111100
    11111100
    真实数据宽可能会大于预览数据宽,如上面表示的那样多出来的宽度补0,所以就导致图片右侧有绿色边缘

    使用shader中进行处理,将shader中的贴图坐标做一个映射,比如将原本的[0,1]映射到[0,0.99],只需要将scaleX改成0.99。
    这样可以处理数据宽度比预览宽度大导致的绿色边缘问题。
    ```shader
    vec2 texCoord = v_texCoord;
    texCoord.x *= scaleX;
    ```
    ```java
    //取两位小数
    float scaleX = (float)(((int)(previewWidth / (float)realWidth * 100)) / 100.0);
    ```
7. android UV数据缺损问题
    类似于下面这种情况,xx代表缺少的字节数量,平白少了几个字节。。。
    111111
    111111
    1111xx
    ```
    //android输出
    stride = 2048 previewWidth = 2048 height = 1536 yLength = 3145728 uvLength = 1572862
    ```
    
    从上面的输出可以看到yLength是正常的,等于 stride * height。
    uvLength本来应该为yLength的一半,即1572864.但是给到的却只有1572862,从而导致显示YUV的时候访问了未知内存而崩溃。
    所以需要对这个缺损的情况做特殊处理.
    ```java
        private void processYUVData(ByteBuffer yBuffer, ByteBuffer uvBuffer,int stride) {
            int realWidth = stride;
            int previewWidth = mPreviewSize.getWidth();
            int height = mPreviewSize.getHeight();

            int uvNeedSize = stride * height/2;
            int addSize = uvNeedSize - uvBuffer.remaining();
            if(mFixUVByteList == null){
                mFixUVByteList = new byte[uvNeedSize];
            }
            //UV数据出现缺损,使用一个足够大小的byte数组做为UV的容器,因为ByteBuffer不能动态更改容量
            if(addSize > 0) {
                uvBuffer.position(0);
                uvBuffer.get(mFixUVByteList,0,uvBuffer.remaining());
            }

            //保留两位小数的缩放值
            float scaleX = (float)(((int)(previewWidth / (float)realWidth * 100)) / 100.0);
            AppActivity.passDataToNative(yBuffer, mFixUVByteList,realWidth, height,mInstanceKey,scaleX);
        }
    ```

8. cocos显示YUV422格式的图片
    cocos直接支持显示RGB格式的图片,但是YUV422转RGB如果在CPU上执行的话会消耗大量的计算资源,并且每帧都进行这个计算会比较卡。
    对每个像素的操作并不复杂,只是因为像素数量比较多所以在CPU上效率比较低，但是放到GPU上进行这个计算就比较合适。
    ```c
    //Y一个贴图  UV一个贴图 
    #ifdef GL_ES
    precision lowp float;
    #endif 

    varying vec4 v_fragmentColor;
    varying vec2 v_texCoord;
    uniform float scaleX;
    void main()
    {
        vec2 texCoord = v_texCoord;
        texCoord.x *= scaleX;
        vec3 yuv;
        vec3 rgb;
        yuv.x = texture2D(CC_Texture0, texCoord).r - 0.0625;
        yuv.y = texture2D(CC_Texture1, texCoord).r - 0.5;
        yuv.z = texture2D(CC_Texture1, texCoord).a - 0.5;
        rgb = mat3(1.164, 1.164, 1.164,
        0.0, -0.392, 2.017,
        1.596, -0.813, 0.0) *
        yuv;
        gl_FragColor = vec4(rgb, 1.0) * v_fragmentColor;
    }
    ```
    ```c++
    void CameraPicture::updateGLTexture()
    {
        float lineScaleList[2] = { 1.0,0.5};
        unsigned char* dataList[2] = { _yData->getBytes(),_uvData->getBytes() };

        int format[] = {GL_LUMINANCE,GL_LUMINANCE_ALPHA};

        for (int i = 0; i < 2; i++)
        {
            int width = _width * lineScaleList[i];
            int height = _height * lineScaleList[i];
            GL::bindTexture2D(texes[i]);
            glTexImage2D(GL_TEXTURE_2D, 0, format[i], width, height, 0, format[i], GL_UNSIGNED_BYTE, dataList[i]);
            GL::bindTexture2D((GLuint)0);
        }
    }
    ```

消耗评估:
因为没有在JAVA和OC层做大量计算,所以时间消耗可以忽略。
传输所用内存峰值为两张图片的量(c++会拷贝数据做下一帧的渲染),所以即使是3000*3000的图峰值内存也就25.75M。
剩下的就是在shader当中的转换的消耗了,可以通过帧率来评估,低端设备都可以维持在50上下(并且还是在有大地图他渲染的情况下),说明效率也没啥问题。