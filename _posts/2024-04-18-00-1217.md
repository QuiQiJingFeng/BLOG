---
layout: post
title:  "cocos 显示摄像头画面遇到的一些问题"
image: ''
date:   2024-04-18 14:08:17
tags:
- Cocos
description: ''
categories: 
- Cocos
---
1. 前置摄像头画面左右相反
    前置摄像头的画面应该跟镜面一样的效果,但是android/ios都是相反的画面,所以做一个沿Y轴反转处理。
2. 充电口左右方向的两种横屏摄像头画面没有跟随旋转
    cocos的画面允许上下反转的情况下,需要获取设备是否反转,然后对摄像头画面旋转180度处理
3. 权限问题
    如果用户第一次拒绝了权限之后,第二次就无法请求权限,所以需要再第二次请求权限失败后弹框引导跳转设置界面的权限界面
4. 摄像头数据格式问题
    IOS和Android的YUV420格式选择后,最终给到的数据却都是YUV422的数据。
    所以需要按照YUV422的格式来处理。 
    其中Y是单独的一块数据,存储着YYYYYY
    UV是连在一起的数,存储着UVUVUV这样的数据
5. android 某些设备的某些预览大小跟最后返回的数据的大小不一致导致画面显示成横条
    ```java
    //真实返回数据的宽度
    int realWidth = image.getPlanes()[0].getRowStride();
    ```
6. 问题5使用了真实宽度之后会在边缘出现绿色的线条
    由于真实返回的数据宽度发生了变化(变大),但是高度没有发生变化,导致一部分数据被填充到了行的末尾。
    即[0,previewWidth)是有数据的，而[previewWidth,stride)补上的Y、UV均为0。
    补充的数据显示出来就是绿色的。

    11111100
    11111100
    11111100
    真实数据宽高可能会大于预览数据宽高,如上面表示的那样多出来的宽度补0,所以就导致图片右侧有绿色边缘

    理论上来说可以通过代码把其中的数据提取出来,但是实际情况下,某些设备的UV数据是有缺损的。
    比如1080*1080的尺寸画面,UV数据大小应该是1080*1080/2=583200
    android获取到的UV大小却是587511,宽度为1088。
    按照android获取到的UV数据看,那么高度是无法整除的,是个小数。
    当按照上面的那样提取指定的有效数据时发现数据不足。
    因为UV数据整体比Y数据小一半,所以当高度取539的时候为最后一行。
    539 * 1088 = 586432  //第539行起始索引
    586432 + 1080 = 587512
    也就是说如果要提取出真实数据,那么android返回的数据至少需要587512个字节,
    但是android返回来的UV数据缺只有587511个字节,这就导致如果想要提取出真实的可用来显示的数据组还需要手动补一个字节进去。

    但是这种补充字节就很麻烦,而且对每个画面都进行筛选真实数据+补充字节的效率问题,
    所以综合考虑这个方案被废弃。

    改为shader中进行处理,将shader中的贴图坐标做一个映射,比如将原本的[0,1]映射到[0,0.99],只需要将scaleX改成0.99即可
    ```shader
    vec2 texCoord = v_texCoord;
    texCoord.x *= scaleX;
    ```
    ```java
    //取两位小数
    float scaleX = (float)(((int)(previewWidth / (float)realWidth * 100)) / 100.0);
    ```

7. android 根据需要显示的区域大小动态选择预览大小从而降低数据传输量  (ios 好像不支持直接设置这个,研究中)
    ```java
        public Size selectOptimalPreviewSize(CameraManager cameraManager, String cameraId, float targetWidth, float targetHeight) {
            try {
                CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId);
                Size[] outputSizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                        .getOutputSizes(SurfaceHolder.class);

                Size optimalSize = null;
                double minDiff = Double.MAX_VALUE;

                for (Size size : outputSizes) {
                    double sizeRatio = (double) size.getWidth() / size.getHeight();
                    double targetRatio = (double) targetWidth / targetHeight;

                    // Check if the aspect ratio matches and if the size is large enough
                    if (Math.abs(sizeRatio - targetRatio) < 0.1 && size.getWidth() >= targetWidth && size.getHeight() >= targetHeight) {
                        double sizeDiff = Math.abs(size.getWidth() - targetWidth) + Math.abs(size.getHeight() - targetHeight);
                        if (sizeDiff < minDiff) {
                            optimalSize = size;
                            minDiff = sizeDiff;
                        }
                    }
                }

                return optimalSize;
            } catch (CameraAccessException e) {
                e.printStackTrace();
            }
            return null;
        }
    ```
8. cocos显示YUV422格式的图片
    cocos直接支持显示RGB格式的图片,但是YUV422转RGB如果在CPU上执行的话会消耗大量的计算资源,并且每帧都进行这个计算会比较卡。
    对每个像素的操作并不复杂,只是因为像素数量比较多所以在CPU上效率比较低，但是放到GPU上进行这个计算就比较合适。
    ```c
    //Y一个贴图  UV一个贴图 
    #ifdef GL_ES
    precision lowp float;
    #endif 

    varying vec4 v_fragmentColor;
    varying vec2 v_texCoord;
    uniform float scaleX;
    void main()
    {
        vec2 texCoord = v_texCoord;
        texCoord.x *= scaleX;
        vec3 yuv;
        vec3 rgb;
        yuv.x = texture2D(CC_Texture0, texCoord).r - 0.0625;
        yuv.y = texture2D(CC_Texture1, texCoord).r - 0.5;
        yuv.z = texture2D(CC_Texture1, texCoord).a - 0.5;
        rgb = mat3(1.164, 1.164, 1.164,
        0.0, -0.392, 2.017,
        1.596, -0.813, 0.0) *
        yuv;
        gl_FragColor = vec4(rgb, 1.0) * v_fragmentColor;
    }
    ```
    ```c++
    void CameraPicture::updateGLTexture()
    {
        float lineScaleList[2] = { 1.0,0.5};
        unsigned char* dataList[2] = { _yData->getBytes(),_uvData->getBytes() };

        int format[] = {GL_LUMINANCE,GL_LUMINANCE_ALPHA};

        for (int i = 0; i < 2; i++)
        {
            int width = _width * lineScaleList[i];
            int height = _height * lineScaleList[i];
            GL::bindTexture2D(texes[i]);
            glTexImage2D(GL_TEXTURE_2D, 0, format[i], width, height, 0, format[i], GL_UNSIGNED_BYTE, dataList[i]);
            GL::bindTexture2D((GLuint)0);
        }
    }
    ```